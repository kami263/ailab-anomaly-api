import torch
import torch.nn as nn
import torch.optim as optim

# AutoEncoder モデル
class AutoEncoder(nn.Module):
    def __init__(self):
        super().__init__()
        self.encoder = nn.Sequential(
            nn.Linear(3, 16),
            nn.ReLU(),
            nn.Linear(16, 8),
            nn.ReLU(),
            nn.Linear(8, 3)  # ボトルネック
        )
        self.decoder = nn.Sequential(
            nn.Linear(3, 8),
            nn.ReLU(),
            nn.Linear(8, 16),
            nn.ReLU(),
            nn.Linear(16, 3)
        )

    def forward(self, x):
        z = self.encoder(x)
        out = self.decoder(z)
        return out


# 正常データのダミー生成（本番ではCSVに置き換える）
def generate_dummy_normal_data(num_samples=200, input_dim=10):
    return torch.randn(num_samples, input_dim)


# AutoEncoder の学習
def train_autoencoder_from_csv(
    csv_path: str,
    num_epochs: int = 300,
    lr: float = 0.01
):
    # 1. CSV を読み込む
    X = load_csv_data(csv_path)

    input_dim = X.shape[1]  # 列数（特徴量数）

    # 2. モデル・損失関数・最適化手法
    model = AutoEncoder()
    criterion = nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=lr)

    # 3. 学習ループ
    for epoch in range(num_epochs):
        model.train()
        outputs = model(X)
        loss = criterion(outputs, X)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        if (epoch + 1) % 50 == 0:
            print(f"Epoch [{epoch+1}/{num_epochs}] Loss: {loss.item():.6f}")

    # ★★★ 学習済みモデルを保存 ★★★

    torch.save(model.state_dict(), "model.pth")
    print("Saved trained model to model.pth")

    return model, input_dim

# 異常スコア計算
def compute_anomaly_score(model, values):
    model.eval()
    x = torch.tensor(values, dtype=torch.float32).unsqueeze(0)

    with torch.no_grad():
        reconstructed = model(x)

    mse = torch.mean((x - reconstructed) ** 2).item()
    return mse
import pandas as pd
import torch

def load_csv_data(path: str) -> torch.Tensor:
    """
    CSV を読み込み、PyTorch Tensor に変換する。
    数値データのみを対象とする。
    """
    df = pd.read_csv(path)

    # 数値列だけ抽出（カテゴリ列が混ざっていてもOK）
    df = df.select_dtypes(include=["number"])

    # DataFrame → Tensor（float32）
    data = torch.tensor(df.values, dtype=torch.float32)

    return data
import torch
import pandas as pd
import numpy as np

MODEL_PATH = "model.pth"
CSV_PATH = "data.csv"

def load_model_and_threshold():
    # モデル構築
    model = AutoEncoder()

    # 学習済みモデルのロード
    model.load_state_dict(torch.load(MODEL_PATH))
    model.eval()

    # CSV から threshold を再計算（平均 + 3σ）
    df = pd.read_csv(CSV_PATH)
    data = df.select_dtypes(include=["number"]).values.astype(np.float32)

    with torch.no_grad():
        x = torch.tensor(data)
        reconstructed = model(x)
        losses = torch.mean((x - reconstructed) ** 2, dim=1).numpy()

    threshold = float(np.mean(losses) + 3 * np.std(losses))

    return model, threshold
